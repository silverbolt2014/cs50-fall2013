<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<!-- saved from url=(0080)http://d2o9nyf4hwsci4.cloudfront.net/2013/fall/lectures/5/w/notes5w/notes5w.html -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<meta name="generator" content="AsciiDoc 8.6.8">
<title>Week 5, continued</title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}


#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
/*
  pygmentize filter
*/
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f4f4f4; }
.highlight .c { color: #008800; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #AA22FF; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #008800; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #008800 } /* Comment.Preproc */
.highlight .c1 { color: #008800; font-style: italic } /* Comment.Single */
.highlight .cs { color: #008800; font-weight: bold } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #AA22FF; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #AA22FF; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #AA22FF; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #AA22FF } /* Keyword.Pseudo */
.highlight .kr { color: #AA22FF; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #00BB00; font-weight: bold } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BB4444 } /* Literal.String */
.highlight .na { color: #BB4444 } /* Name.Attribute */
.highlight .nb { color: #AA22FF } /* Name.Builtin */
.highlight .nc { color: #0000FF } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #00A000 } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #B8860B } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BB4444 } /* Literal.String.Backtick */
.highlight .sc { color: #BB4444 } /* Literal.String.Char */
.highlight .sd { color: #BB4444; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BB4444 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BB4444 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BB4444 } /* Literal.String.Single */
.highlight .ss { color: #B8860B } /* Literal.String.Symbol */
.highlight .bp { color: #AA22FF } /* Name.Builtin.Pseudo */
.highlight .vc { color: #B8860B } /* Name.Variable.Class */
.highlight .vg { color: #B8860B } /* Name.Variable.Global */
.highlight .vi { color: #B8860B } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */



</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install(2);
/*]]>*/
</script>
</head>
<body class="article">
<div id="header">
<h1>Week 5, continued</h1>
<span id="author">Andrew Sellergren</span><br>
<div id="toc">
  <div id="toctitle">Table of Contents</div>
  <noscript>&lt;p&gt;&lt;b&gt;JavaScript must be enabled in your browser to display the table of contents.&lt;/b&gt;&lt;/p&gt;</noscript>
<div class="toclevel1"><a href="http://d2o9nyf4hwsci4.cloudfront.net/2013/fall/lectures/5/w/notes5w/notes5w.html#_announcements_and_demos">Announcements and Demos</a></div><div class="toclevel1"><a href="http://d2o9nyf4hwsci4.cloudfront.net/2013/fall/lectures/5/w/notes5w/notes5w.html#_compiling">Compiling</a></div><div class="toclevel1"><a href="http://d2o9nyf4hwsci4.cloudfront.net/2013/fall/lectures/5/w/notes5w/notes5w.html#_memory">Memory</a></div><div class="toclevel2"><a href="http://d2o9nyf4hwsci4.cloudfront.net/2013/fall/lectures/5/w/notes5w/notes5w.html#_the_stack">The Stack</a></div><div class="toclevel2"><a href="http://d2o9nyf4hwsci4.cloudfront.net/2013/fall/lectures/5/w/notes5w/notes5w.html#_the_heap">The Heap</a></div><div class="toclevel2"><a href="http://d2o9nyf4hwsci4.cloudfront.net/2013/fall/lectures/5/w/notes5w/notes5w.html#_valgrind">Valgrind</a></div><div class="toclevel1"><a href="http://d2o9nyf4hwsci4.cloudfront.net/2013/fall/lectures/5/w/notes5w/notes5w.html#_the_cs50_library">The CS50 Library</a></div><div class="toclevel1"><a href="http://d2o9nyf4hwsci4.cloudfront.net/2013/fall/lectures/5/w/notes5w/notes5w.html#_structs">Structs</a></div><div class="toclevel1"><a href="http://d2o9nyf4hwsci4.cloudfront.net/2013/fall/lectures/5/w/notes5w/notes5w.html#_images">Images</a></div></div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_announcements_and_demos">Announcements and Demos</h2>
<div class="sectionbody">
<div class="ulist"><ul>
<li>
<p>
No lecture on Monday 10/14 or Friday 10/18 (even though it says so in the syllabus)!  There will be a quiz review session on Monday, though, which we’ll announce by e-mail and on the course website.  Sections will meet on Monday, but you can attend another section or watch the video online if you want.
</p>
</li>
<li>
<p>
Quiz 0 is on Wednesday 10/16.
</p>
</li>
<li>
<p>
After Quiz 0, we’ll dive into the world of forensics.  David and a few of the teaching fellows will walk around campus taking pictures, but unfortunately delete them from their memory card.  It will be your job to recover them!
</p>
</li>
<li>
<p>
In the coming weeks, we’ll also talk more about graphics and images.  We’ll learn that "link:zoom and enhance" is not really as useful as <a href="http://www.youtube.com/watch?v=Vxq9yj2pVWk">TV shows and movies would suggest</a>.
</p>
</li>
</ul></div>
</div>
</div>
<div class="sect1">
<h2 id="_compiling">Compiling</h2>
<div class="sectionbody">
<div class="ulist"><ul>
<li>
<p>
What we call "compiling" a program actually consists of four steps:
</p>
<div class="ulist"><ul>
<li>
<p>
pre-processing
</p>
</li>
<li>
<p>
compiling
</p>
</li>
<li>
<p>
assembling
</p>
</li>
<li>
<p>
linking
</p>
</li>
</ul></div>
</li>
<li>
<p>
Lines of code that begin with <code>#</code>, such as <code>#define</code> and <code>#include</code> are <em>pre-processor directives</em>.  When you write <code>#include &lt;stdio.h&gt;</code>, it instructs the compiler to fetch the contents of <code>stdio.h</code> and paste them into your program before it begins translating into 0s and 1s.  This occurs during the pre-processing step.
</p>
</li>
<li>
<p>
Compiling actually involves translating C into assembly language.  Assembling translates assembly language to binary.  Finally, linking combines the 0s and 1s of your program with 0s and 1s of other people’s code.
</p>
</li>
<li>
<p>
To see what’s going on during the compiling step, let’s run <code>clang -S</code> on our <code>hello.c</code> program.  This creates a file named <code>hello.S</code> written in assembly language.  If you open this up, you’ll see instructions like <code>pushl</code> and <code>movl</code> that manipulate <em>registers</em>, very small memory containers.  These instructions vary between CPUs.
</p>
</li>
<li>
<p>
The following diagram shows how these four steps of compiling connect with each other:
</p>
<div class="imageblock">
<div class="content">
<img src="./Week 5, continued_files/compiling.png" alt="The four steps of compiling.">
</div>
</div>
</li>
</ul></div>
</div>
</div>
<div class="sect1">
<h2 id="_memory">Memory</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_the_stack">The Stack</h3>
<div class="ulist"><ul>
<li>
<p>
Recall from last time our picture of a program’s memory:
</p>
<div class="imageblock">
<div class="content">
<img src="./Week 5, continued_files/program_memory.png" alt="A program&#39;s memory.">
</div>
</div>
</li>
<li>
<p>
At the top, the text segment contains the actual 0s and 1s of the program.  Below that are the initialized data and uninitialized data segments that contain global variables.  We’ll talk more about the heap later.
</p>
</li>
<li>
<p>
The stack is the segment of memory on which frames are layered for each function call, including <code>main</code>.  In <code>swap.c</code>, we saw that we could manipulate the frame of <code>main</code> while within <code>swap</code> if we passed it pointers to variables in the scope of <code>main</code>.
</p>
</li>
<li>
<p>
We also learned that if we don’t check the bounds of our arrays, we leave our programs susceptible to stack overflows, or buffer overrun attacks.  This is an exploit by which an adversary passes input to a program that overwrites memory it shouldn’t have access to.
</p>
</li>
</ul></div>
</div>
<div class="sect2">
<h3 id="_the_heap">The Heap</h3>
<div class="ulist"><ul>
<li>
<p>
Let’s look underneath the hood of a simple program:
</p>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span class="cp">#include &lt;cs50.h&gt;</span>
<span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"State your name: "</span><span class="p">);</span>
    <span class="n">string</span> <span class="n">name</span> <span class="o">=</span> <span class="n">GetString</span><span class="p">();</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"hello, %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
<span class="p">}</span>
</pre></div></div></div>
</li>
<li>
<p>
First, we know that a <code>string</code> is really just a <code>char *</code>:
</p>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span class="cp">#include &lt;cs50.h&gt;</span>
<span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"State your name: "</span><span class="p">);</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">name</span> <span class="o">=</span> <span class="n">GetString</span><span class="p">();</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"hello, %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
<span class="p">}</span>
</pre></div></div></div>
</li>
<li>
<p>
Where is the memory for the string coming from?  <code>GetString</code> is a function, so it gets its own frame on the stack.  However, if we stored the string there, it would disappear as soon as <code>GetString</code> returned.  Instead, we will store it in the <em>heap</em>.  This is where <code>malloc</code> allocates memory.
</p>
</li>
<li>
<p>
You can tell from the diagram that this design isn’t perfect.  If the stack grows upward and the heap grows downward, there’s a chance that they’ll collide.  We can see this with a simple program like the following:
</p>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">foo</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">foo</span><span class="p">();</span>
<span class="p">}</span>
</pre></div></div></div>
</li>
<li>
<p>
Obviously, this is a poorly designed program since it has a function that simply calls itself.  If we compile and run this, we get a segmentation fault.  Every time <code>foo</code> is called, a new stack frame is allocated.  Eventually, the program runs out of memory with which to allocate these frames.
</p>
</li>
<li>
<p>
Normally, recursive functions have a <em>base case</em> in which they stop calling themselves.  Even if a base case is defined, though, a recursive function can still exhaust all available memory if it calls itself too many times before hitting the base case.
</p>
</li>
</ul></div>
</div>
<div class="sect2">
<h3 id="_valgrind">Valgrind</h3>
<div class="ulist"><ul>
<li>
<p>
One gotcha with allocating memory on the heap is that we need to explicitly free it up when we’re not using it anymore.  Thus far, we’ve not been doing this when we call <code>GetString</code>.  We can see that this memory is not being freed by running a tool called Valgrind.  Valgrind executes programs and assesses them for these so-called <em>memory leaks</em>.  You may have witnessed the effects of memory leaks in your daily life if you’ve ever left many programs running on your computer for a long time and noticed that the computer seems to slow down.
</p>
</li>
<li>
<p>
When we run <code>valgrind ./hello-2</code> and type "David," we get a lot of output, but one line in particular stands out:
</p>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span class="n">HEAP</span> <span class="n">SUMMARY</span><span class="o">:</span>
    <span class="n">in</span> <span class="n">use</span> <span class="n">at</span> <span class="n">exit</span><span class="o">:</span> <span class="mi">6</span> <span class="n">bytes</span> <span class="n">in</span> <span class="mi">1</span> <span class="n">blocks</span>
</pre></div></div></div>
</li>
<li>
<p>
Those 6 bytes are the ones that were allocated to store the string "David."
</p>
</li>
<li>
<p>
If we pass the command-line flag <code>--leak-check=full</code> to Valgrind, we get a more detailed report of where the memory leaks in our code are.
</p>
</li>
<li>
<p>
How do we fix this memory leak?  We just need to add one line of code:
</p>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span class="cp">#include &lt;cs50.h&gt;</span>
<span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"State your name: "</span><span class="p">);</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">name</span> <span class="o">=</span> <span class="n">GetString</span><span class="p">();</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"hello, %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
<span class="p">}</span>
</pre></div></div></div>
</li>
<li>
<p>
Now when we run this through Valgrind, we see the following output:
</p>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span class="n">All</span> <span class="n">heap</span> <span class="n">blocks</span> <span class="n">were</span> <span class="n">freed</span> <span class="o">--</span> <span class="n">no</span> <span class="n">leaks</span> <span class="n">are</span> <span class="n">possible</span>
</pre></div></div></div>
</li>
<li>
<p>
Valgrind can also help identify programming errors related to overstepping the bounds of arrays:
</p>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span class="cp">#include &lt;stdlib.h&gt;</span>

<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">x</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
    <span class="n">x</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">f</span><span class="p">();</span>
<span class="p">}</span>
</pre></div></div></div>
</li>
<li>
<p>
Note that although <code>x</code> points to a chunk of memory (probably of size 40 bytes) that can store 10 <code>int</code> values, the array is zero-indexed, so <code>x[10]</code> is actually overstepping the bounds of the array.  When we run this program through Valgrind, we get a line of output like so:
</p>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span class="n">Invalid</span> <span class="n">write</span> <span class="n">of</span> <span class="n">size</span> <span class="mi">4</span>
</pre></div></div></div>
</li>
<li>
<p>
This line refers to the fact that we tried to write 4 bytes (an <code>int</code>) to a chunk of memory that doesn’t really belong to our program.
</p>
</li>
<li>
<p>
Valgrind also tells us that we’re not freeing the 40 bytes of memory that <code>x</code> points to.
</p>
</li>
</ul></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_the_cs50_library">The CS50 Library</h2>
<div class="sectionbody">
<div class="ulist"><ul>
<li>
<p>
The CS50 Library is a set of functions and types we provided you to make it easier to get user input. In it, we also defined a <code>string</code> to be a <code>char*</code> until we could reveal to you what a pointer is:
</p>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span class="k">typedef</span> <span class="kt">char</span><span class="o">*</span> <span class="n">string</span><span class="p">;</span>
</pre></div></div></div>
</li>
<li>
<p>
Let’s peek at the definition of <code>GetChar</code>:
</p>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span class="cm">/**</span>
<span class="cm"> * Reads a line of text from standard input and returns the equivalent</span>
<span class="cm"> * char; if text does not represent a char, user is prompted to retry.</span>
<span class="cm"> * Leading and trailing whitespace is ignored.  If line can't be read,</span>
<span class="cm"> * returns CHAR_MAX.</span>
<span class="cm"> */</span>
<span class="kt">char</span> <span class="nf">GetChar</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// try to get a char from user</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// get line of text, returning CHAR_MAX on failure</span>
        <span class="n">string</span> <span class="n">line</span> <span class="o">=</span> <span class="n">GetString</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">line</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="n">CHAR_MAX</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// return a char if only a char (possibly with</span>
        <span class="c1">// leading and/or trailing whitespace) was provided</span>
        <span class="kt">char</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">sscanf</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="s">" %c %c"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">free</span><span class="p">(</span><span class="n">line</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">c1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">free</span><span class="p">(</span><span class="n">line</span><span class="p">);</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"Retry: "</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div></div></div>
</li>
<li>
<p>
Why do we return <code>CHAR_MAX</code> if we fail to get a line of text from the user?  <code>GetChar</code> returns a <code>char</code> according to its definition, so we need one <code>char</code> value that signals failure.  By convention, this <em>sentinel value</em> is 255, the maximum possible value of a <code>char</code>.  That means that we can’t distinguish the case of an error from the case of the user typing the <code>char</code> 255, but since 255 is not something you can type on your keyboard, that’s okay.
</p>
</li>
<li>
<p>
<code>sscanf</code> is a function used for scanning formatted strings.  Here, we pass it the line of text we got from the user, a format string, and the address of two <code>char</code> variables.  <code>sscanf</code> will try to interpret the line of text as two characters in a row and fill in <code>c1</code> and <code>c2</code> accordingly.  What we’re hoping is that only <code>c1</code> will actually be populated.  If both <code>c1</code> and <code>c2</code> are populated, it means the user typed more than one character, which is not what we asked for.  If only <code>c1</code> is populated, then <code>sscanf</code> will return 1 and we can return <code>c1</code>.
</p>
</li>
</ul></div>
</div>
</div>
<div class="sect1">
<h2 id="_structs">Structs</h2>
<div class="sectionbody">
<div class="ulist"><ul>
<li>
<p>
Just like we used <code>typedef</code> to create the <code>string</code> type in the CS50 Library, you can use it to define your own types:
</p>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span class="cp">#include &lt;cs50.h&gt;</span>

<span class="c1">// structure representing a student</span>
<span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">id</span><span class="p">;</span>
    <span class="n">string</span> <span class="n">name</span><span class="p">;</span>
    <span class="n">string</span> <span class="n">house</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">student</span><span class="p">;</span>
</pre></div></div></div>
</li>
<li>
<p>
Here we’re defining a variable type named <code>student</code>.  Inside of this type, which is actually a <em>struct</em>, there are three variables representing the ID, name, and house of the student.  To access these variables within a <code>student</code>, we use dot notation:
</p>
<div class="listingblock">
<div class="content"><table class="highlighttable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44</pre></div></td><td class="code"><div class="highlight"><pre><span class="cp">#include &lt;cs50.h&gt;</span>
<span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;string.h&gt;</span>

<span class="cp">#include "structs.h"</span>

<span class="c1">// class size</span>
<span class="cp">#define STUDENTS 3</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// declare class</span>
    <span class="n">student</span> <span class="n">class</span><span class="p">[</span><span class="n">STUDENTS</span><span class="p">];</span>

    <span class="c1">// populate class with user's input</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">STUDENTS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Student's ID: "</span><span class="p">);</span>
        <span class="n">class</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">id</span> <span class="o">=</span> <span class="n">GetInt</span><span class="p">();</span>

        <span class="n">printf</span><span class="p">(</span><span class="s">"Student's name: "</span><span class="p">);</span>
        <span class="n">class</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span> <span class="o">=</span> <span class="n">GetString</span><span class="p">();</span>

        <span class="n">printf</span><span class="p">(</span><span class="s">"Student's house: "</span><span class="p">);</span>
        <span class="n">class</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">house</span> <span class="o">=</span> <span class="n">GetString</span><span class="p">();</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// now print anyone in Mather</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">STUDENTS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">class</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">house</span><span class="p">,</span> <span class="s">"Mather"</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"%s is in Mather!</span><span class="se">\n\n</span><span class="s">"</span><span class="p">,</span> <span class="n">class</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// free memory</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">STUDENTS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">free</span><span class="p">(</span><span class="n">class</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">);</span>
        <span class="n">free</span><span class="p">(</span><span class="n">class</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">house</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div></div>
</li>
<li>
<p>
In line 13, we declare an array of <code>student</code>.  We then loop through that array and populate it with data from the user.
</p>
</li>
</ul></div>
</div>
</div>
<div class="sect1">
<h2 id="_images">Images</h2>
<div class="sectionbody">
<div class="ulist"><ul>
<li>
<p>
There are many different file formats used to store images.  One such format is a <em>bitmap</em>, or BMP.  A very simple bitmap might use 0 to represent black and 1 to represent white, so a series of 0s and 1s could store a black-and-white image.
</p>
</li>
<li>
<p>
More sophisticated file formats like JPEG store 0s and 1s for the image itself but also metadata.  In Problem Set 5, you’ll use this fact to detect JPEGs that have been lost on David’s memory card.
</p>
</li>
</ul></div>
</div>
</div>
</div>

<div id="footer">
<div id="footer-text">
Last updated 2013-10-12 23:33:02 PDT
</div>
</div>


</body></html>