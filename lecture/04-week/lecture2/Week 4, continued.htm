<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<!-- saved from url=(0080)http://d2o9nyf4hwsci4.cloudfront.net/2013/fall/lectures/4/w/notes4w/notes4w.html -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<meta name="generator" content="AsciiDoc 8.6.8">
<title>Week 4, continued</title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}


#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
/*
  pygmentize filter
*/
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f4f4f4; }
.highlight .c { color: #008800; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #AA22FF; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #008800; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #008800 } /* Comment.Preproc */
.highlight .c1 { color: #008800; font-style: italic } /* Comment.Single */
.highlight .cs { color: #008800; font-weight: bold } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #AA22FF; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #AA22FF; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #AA22FF; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #AA22FF } /* Keyword.Pseudo */
.highlight .kr { color: #AA22FF; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #00BB00; font-weight: bold } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BB4444 } /* Literal.String */
.highlight .na { color: #BB4444 } /* Name.Attribute */
.highlight .nb { color: #AA22FF } /* Name.Builtin */
.highlight .nc { color: #0000FF } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #00A000 } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #B8860B } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BB4444 } /* Literal.String.Backtick */
.highlight .sc { color: #BB4444 } /* Literal.String.Char */
.highlight .sd { color: #BB4444; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BB4444 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BB4444 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BB4444 } /* Literal.String.Single */
.highlight .ss { color: #B8860B } /* Literal.String.Symbol */
.highlight .bp { color: #AA22FF } /* Name.Builtin.Pseudo */
.highlight .vc { color: #B8860B } /* Name.Variable.Class */
.highlight .vg { color: #B8860B } /* Name.Variable.Global */
.highlight .vi { color: #B8860B } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */



</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install(2);
/*]]>*/
</script>
</head>
<body class="article">
<div id="header">
<h1>Week 4, continued</h1>
<span id="author">Andrew Sellergren</span><br>
<div id="toc">
  <div id="toctitle">Table of Contents</div>
  <noscript>&lt;p&gt;&lt;b&gt;JavaScript must be enabled in your browser to display the table of contents.&lt;/b&gt;&lt;/p&gt;</noscript>
<div class="toclevel1"><a href="http://d2o9nyf4hwsci4.cloudfront.net/2013/fall/lectures/4/w/notes4w/notes4w.html#_announcements_and_demos">Announcements and Demos</a></div><div class="toclevel1"><a href="http://d2o9nyf4hwsci4.cloudfront.net/2013/fall/lectures/4/w/notes4w/notes4w.html#_pointers">Pointers</a></div><div class="toclevel2"><a href="http://d2o9nyf4hwsci4.cloudfront.net/2013/fall/lectures/4/w/notes4w/notes4w.html#_code_noswap_c_code">noswap.c</a></div><div class="toclevel2"><a href="http://d2o9nyf4hwsci4.cloudfront.net/2013/fall/lectures/4/w/notes4w/notes4w.html#_code_swap_c_code">swap.c</a></div><div class="toclevel2"><a href="http://d2o9nyf4hwsci4.cloudfront.net/2013/fall/lectures/4/w/notes4w/notes4w.html#_code_compare_0_c_code">compare-0.c</a></div><div class="toclevel2"><a href="http://d2o9nyf4hwsci4.cloudfront.net/2013/fall/lectures/4/w/notes4w/notes4w.html#_code_copy_0_c_code">copy-0.c</a></div><div class="toclevel2"><a href="http://d2o9nyf4hwsci4.cloudfront.net/2013/fall/lectures/4/w/notes4w/notes4w.html#_code_compare_1_c_code">compare-1.c</a></div><div class="toclevel2"><a href="http://d2o9nyf4hwsci4.cloudfront.net/2013/fall/lectures/4/w/notes4w/notes4w.html#_code_copy_1_c_code">copy-1.c</a></div><div class="toclevel2"><a href="http://d2o9nyf4hwsci4.cloudfront.net/2013/fall/lectures/4/w/notes4w/notes4w.html#_teaser">Teaser</a></div></div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_announcements_and_demos">Announcements and Demos</h2>
<div class="sectionbody">
<div class="ulist"><ul>
<li>
<p>
Fifth Monday is on 10/7!  This is the deadline for changing your grading status in the course.  Switching to SAT/UNS or Pass/Fail requires a signature, so please do approach David, Rob, or Lauren if you need.
</p>
</li>
</ul></div>
</div>
</div>
<div class="sect1">
<h2 id="_pointers">Pointers</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_code_noswap_c_code"><code>noswap.c</code></h3>
<div class="ulist"><ul>
<li>
<p>
Pointers are one of the more complex topics we cover, so don’t feel bad if your mind feels stretched in the next few weeks.  That’s a good thing!
</p>
</li>
<li>
<p>
Recall last time we ended with a function that didn’t live up to its name:
</p>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"x is %i</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"y is %i</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Swapping...</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">swap</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Swapped!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"x is %i</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"y is %i</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span>
</pre></div></div></div>
</li>
<li>
<p>
Though we expected to see <code>x</code> and <code>y</code> have the values 2 and 1, respectively, we actually saw that they still had their original values 1 and 2.
</p>
</li>
<li>
<p>
To see why this doesn’t work, let’s bring a volunteer onstage.  We’ll ask her to pour orange juice and milk into two separate glasses representing two different <code>int</code>.  If we ask her to swap the orange juice and milk, she wisely chooses to use another glass.  This glass represents some temporary storage which we call <code>tmp</code> in the <code>swap</code> function above.  Interestingly, if we implement the same code directly in <code>main</code>, the swapping actually works:
</p>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"x is %i</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"y is %i</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Swapping...</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

    <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"Swapped!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"x is %i</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"y is %i</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
<span class="p">}</span>
</pre></div></div></div>
</li>
<li>
<p>
So why does this logic work in <code>main</code> but not in <code>swap</code>?  <code>a</code> and <code>b</code> are actually copies of <code>x</code> and <code>y</code>, so when we swap <code>a</code> and <code>b</code>, <code>x</code> and <code>y</code> are unchanged.
</p>
</li>
<li>
<p>
One way to fix this would be to make <code>x</code> and <code>y</code> global variables, declaring them outside of <code>main</code>.  In <code>fifteen.c</code>, it made sense to make certain variables global because they were to be used by the whole program.  However, in a small program like <code>noswap.c</code>, using global variables is sloppy design.
</p>
</li>
</ul></div>
</div>
<div class="sect2">
<h3 id="_code_swap_c_code"><code>swap.c</code></h3>
<div class="ulist"><ul>
<li>
<p>
How can we change the definition of <code>swap</code> to work as intended?  Turns out we just need to add asterisks:
</p>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="o">*</span><span class="n">a</span><span class="p">;</span>
    <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="o">*</span><span class="n">b</span><span class="p">;</span>
    <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span>
</pre></div></div></div>
</li>
<li>
<p>
What is an <code>int*</code>?  It’s the memory address of an <code>int</code>.  More properly speaking, it is a <em>pointer</em> to an <code>int</code>.  If your computer has 2 gigabytes of RAM, then there are 2 billion bytes, each of which has a memory address.  Let’s say the <code>int</code> that <code>a</code> points to is stored at the 123<sup>rd</sup> byte of RAM.  The value of <code>a</code> then, is 123.  To get at the actual integer value that’s stored at byte 123, we write <code>*a</code>.  <code>*a = *b</code> says "store at location <code>a</code> whatever is at location <code>b</code>."
</p>
</li>
<li>
<p>
Now that we’ve changed <code>swap</code>, we need to change how we call <code>swap</code>.  Instead of passing <code>x</code> and <code>y</code>, we want to pass the address of <code>x</code> and the address of <code>y</code>:
</p>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span class="n">swap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">y</span><span class="p">)</span>
</pre></div></div></div>
</li>
<li>
<p>
<code>&amp;</code> is the "address-of" operator and <code>*</code> is the dereference operator.
</p>
</li>
<li>
<p>
Let’s assume our integers 1 and 2 are stored next to each other in memory and 1 is stored at byte 123.  That means 2 is stored 4 bytes away (since an <code>int</code> requires 4 bytes), so we’ll assume that it’s stored at byte 127.  The values of <code>a</code> and <code>b</code>, then, are 123 and 127.  We can simulate passing those to <code>swap</code> by writing them on pieces of paper and putting them in a black box.
</p>
</li>
<li>
<p>
We ask a volunteer to come onstage and retrieve the pieces of paper from the black box.  Next he needs to allocate a little bit of memory for variable <code>tmp</code>.  In <code>tmp</code>, he stores the value of the <code>int</code> whose address is in <code>a</code>.  This is 1.
</p>
</li>
<li>
<p>
Next, at address 123, he erases the number 1 and writes in the number 2.  This corresponds to the <code>*a = *b</code> line, which says "store at location <code>a</code> whatever is at location <code>b</code>."
</p>
</li>
<li>
<p>
Finally, at address 127, he erases the number 2 and writes in the number 2, which was stored in <code>tmp</code>.  <code>tmp</code> is a local variable, but goes away when <code>swap</code> returns.
</p>
</li>
</ul></div>
</div>
<div class="sect2">
<h3 id="_code_compare_0_c_code"><code>compare-0.c</code></h3>
<div class="ulist"><ul>
<li>
<p>
For the first few weeks, we have worked with <code>string</code> as a data type.  However, this is a type that we defined for you in the CS50 Library.  A <code>string</code> is really a <code>char*</code>.  It’s the address of a <code>char</code>.  In fact, it’s the address of the first <code>char</code> in the string.
</p>
</li>
<li>
<p>
Consider the following program which claims to compare two strings:
</p>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span class="cp">#include &lt;cs50.h&gt;</span>
<span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// get line of text</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Say something: "</span><span class="p">);</span>
    <span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="n">GetString</span><span class="p">();</span>

    <span class="c1">// get another line of text</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Say something: "</span><span class="p">);</span>
    <span class="n">string</span> <span class="n">t</span> <span class="o">=</span> <span class="n">GetString</span><span class="p">();</span>

    <span class="c1">// try (and fail) to compare strings</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="n">t</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"You typed the same thing!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"You typed different things!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div></div></div>
</li>
<li>
<p>
Here, we simply ask the user for two strings and store them in <code>s</code> and <code>t</code>.  Then we ask if <code>s == t</code>.  Seems reasonable, no?  We’ve used the <code>==</code> operator for all the other data types we’ve seen thus far.
</p>
</li>
<li>
<p>
But if we compile and run this program, typing "hello" twice, we always get "You typed different things!"
</p>
</li>
<li>
<p>
Recall that a string is just an array of characters, so "hello" looks like this in memory:
</p>
<div class="tableblock">
<table rules="all" width="20%" frame="border" cellspacing="0" cellpadding="4">
<colgroup><col width="16%">
<col width="16%">
<col width="16%">
<col width="16%">
<col width="16%">
<col width="16%">
</colgroup><tbody>
<tr>
<td align="left" valign="top"><p class="table"><code>h</code></p></td>
<td align="left" valign="top"><p class="table"><code>e</code></p></td>
<td align="left" valign="top"><p class="table"><code>l</code></p></td>
<td align="left" valign="top"><p class="table"><code>l</code></p></td>
<td align="left" valign="top"><p class="table"><code>o</code></p></td>
<td align="left" valign="top"><p class="table"><code>\0</code></p></td>
</tr>
</tbody>
</table>
</div>
</li>
<li>
<p>
Although we’re able to access the first character "h" using bracket notation, under the hood it’s really located at one of 2 billion or so memory addresses.  Let’s call it address 123 again.  Then "e" is at address 124, "l" is at address 125, and so on.  A <code>char</code> only takes 1 byte, so this time the memory addresses are only 1 apart.
</p>
</li>
<li>
<p>
If <code>GetString</code> is getting us this string, then what does it actually return?  The number 123!  Before it does so, it allocates the memory necessary to store "hello" and inserts those characters along with the null terminator.
</p>
</li>
<li>
<p>
But if we only know the memory address of the first character, how do we know how long the string is?  Recall that strings end with the special <code>\0</code> character, so we can just iterate until we find it.
</p>
</li>
<li>
<p>
<code>compare-0.c</code> is buggy because it’s comparing the memory addresses of the two strings, not the strings themselves.  Maybe <code>s</code> is stored at memory address 123 and <code>t</code> is stored at memory address 200.  Since 123 does not equal 200, our program says they’re different strings.
</p>
</li>
</ul></div>
</div>
<div class="sect2">
<h3 id="_code_copy_0_c_code"><code>copy-0.c</code></h3>
<div class="ulist"><ul>
<li>
<p>
Let’s take a look at a program that tries, but fails to copy a string:
</p>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span class="cp">#include &lt;cs50.h&gt;</span>
<span class="cp">#include &lt;ctype.h&gt;</span>
<span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;string.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// get line of text</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Say something: "</span><span class="p">);</span>
    <span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="n">GetString</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// try (and fail) to copy string</span>
    <span class="n">string</span> <span class="n">t</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>

    <span class="c1">// change "copy"</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Capitalizing copy...</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">toupper</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="c1">// print original and "copy"</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Original: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Copy:     %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
<span class="p">}</span>
</pre></div></div></div>
</li>
<li>
<p>
We check that <code>s</code> isn’t <code>NULL</code> in case the user has given us more characters than we have memory for.  <code>NULL</code> is actually the memory address 0.  By convention, no user data can ever be stored at byte 0, so if a program tries to access this memory address, it will crash.
</p>
</li>
<li>
<p>
<code>'\0'</code> is a byte in which all bits are zero
</p>
</li>

<li>
<p>
Now that we have the user-provided string in <code>s</code>, we assign the value of <code>s</code> to <code>t</code>.  But if <code>s</code> is just a memory address, say 123, then <code>t</code> is now the same memory address.  Both <code>s</code> and <code>t</code> are pointing to the same chunks of memory.
</p>
</li>
<li>
<p>
To prove that this program is buggy, we’ll try to capitalize <code>t</code>, but not <code>s</code>.  The output, though, shows that both <code>s</code> and <code>t</code> are capitalized.
</p>
</li>
<li>
<p>
To emphasize that their role is to <em>point</em> to other variables, pointers are often represented as arrows.
</p>
</li>
</ul></div>
</div>
<div class="sect2">
<h3 id="_code_compare_1_c_code"><code>compare-1.c</code></h3>
<div class="ulist"><ul>
<li>
<p>
Finally, a program that truly compares two strings:
</p>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span class="cp">#include &lt;cs50.h&gt;</span>
<span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;string.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// get line of text</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Say something: "</span><span class="p">);</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">s</span> <span class="o">=</span> <span class="n">GetString</span><span class="p">();</span>

    <span class="c1">// get another line of text</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Say something: "</span><span class="p">);</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">t</span> <span class="o">=</span> <span class="n">GetString</span><span class="p">();</span>

    <span class="c1">// try to compare strings</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">t</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"You typed the same thing!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"You typed different things!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div></div></div>
</li>
<li>
<p>
Now that we know a <code>string</code> is really just a <code>char*</code>, we need to be careful it’s not <code>NULL</code>.
</p>
</li>
<li>
<p>
<code>strcmp</code> is short for "string compare."  It’s a function that comes in <code>string.h</code>, which, according to the man page, returns 0 if two strings are identical, a negative number if the first string argument comes before the second string alphabetically, or a positive number if the first string argument comes after the second string alphabetically.
</p>
</li>
</ul></div>
</div>
<div class="sect2">
<h3 id="_code_copy_1_c_code"><code>copy-1.c</code></h3>
<div class="ulist"><ul>
<li>
<p>
Copying a string is a little more complicated than just using the assignment operator:
</p>
<div class="listingblock">
<div class="content"><table class="highlighttable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43</pre></div></td><td class="code"><div class="highlight"><pre><span class="cp">#include &lt;cs50.h&gt;</span>
<span class="cp">#include &lt;ctype.h&gt;</span>
<span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;string.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// get line of text</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Say something: "</span><span class="p">);</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">s</span> <span class="o">=</span> <span class="n">GetString</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// allocate enough space for copy</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">t</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">((</span><span class="n">strlen</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// copy string, including '\0' at end</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="c1">// change copy</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Capitalizing copy...</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">toupper</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="c1">// print original and copy</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Original: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Copy:     %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>

    <span class="c1">// success</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div></div>
</li>
<li>
<p>
In line 17, we’re declaring a pointer <code>t</code> and initializing it with the return value of a function named <code>malloc</code>.  <code>malloc</code> takes a single argument, the number of bytes of memory requested, and returns the address in memory of the first of those bytes or <code>NULL</code> if the memory couldn’t be allocated.
</p>
</li>
<li>
<p>
In this case, we’re allocating enough memory for all the characters in <code>s</code> plus 1 extra for the null terminator.  We multiply this number of characters by <code>sizeof(char)</code>, which gives the size in bytes of a <code>char</code> on this particular operating system.  Normally it will be 1, but we’re handling other cases correctly, too.
</p>
</li>
<li>
<p>
Once we have enough memory, we iterate through all of the characters in <code>s</code> and assign them one at a time to <code>t</code>.
</p>
</li>
</ul></div>
</div>
<div class="sect2">
<h3 id="_teaser">Teaser</h3>
<div class="ulist"><ul>
<li>
<p>
Let’s analyze some seemingly innocuous lines of code:
</p>
<div class="listingblock">
<div class="content"><table class="highlighttable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15</pre></div></td><td class="code"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">x</span><span class="p">;</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">y</span><span class="p">;</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>

    <span class="o">*</span><span class="n">x</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>

    <span class="o">*</span><span class="n">y</span> <span class="o">=</span> <span class="mi">13</span><span class="p">;</span>

    <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>

    <span class="o">*</span><span class="n">y</span> <span class="o">=</span> <span class="mi">13</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div></div>
</li>
<li>
<p>
First, we declare two pointers <code>x</code> and <code>y</code>.  We allocate enough memory to store an <code>int</code> and assign its address to <code>x</code>.  We store the value 42 in this memory.  Then we store in the memory address <code>y</code> the value 13.  But wait, we didn’t allocate memory for a second <code>int</code>, so what does <code>y</code> point to?  Who knows!  That’s the problem.  Line 10 is pretty painful for <a href="http://www.youtube.com/watch?v=6pmWojisM_E">Binky</a>.
</p>
</li>
</ul></div>
</div>
</div>
</div>
</div>

<div id="footer">
<div id="footer-text">
Last updated 2013-10-25 12:28:03 PDT
</div>
</div>


</body></html>